The project uses several design patterns to minimize redundant code and make adding new features easier:

Proxy Class: The GameClient class is a GameLevel that passes events and loop methods to the top of a Stack. The main
thread flushes swing events between loops, so you can expect them to come in one at a time.

State Stack: The current GameLevel is stored on top of a Stack. Menus and game modes can be displayed by simply passing
them to getState().push, as opposed to using some global enumeration, which avoids lots of bugs and null checks. For
examples of how to use the state stack, see GameMode or the Waves and Walls classes.

Random Object Factories: Almost every class in the game had a different way of creating random objects when we got the
project. To make the code more predictable and less redundant, we added a RandomDifferentElement class to our own
Random implementation, that returns different random elements of a list. To create random new instances of different
classes, you can use method references to pass the constructors of other classes to its own constructor, for example
like in Waves.Spawn. This is very different than the implementations of the Factory pattern you have seen in school,
because it uses Java 8 features to avoid declaring a new class for every factory method. (Java 8 method references
basically just do that automatically instead.) This saved many, many lines of code, so try to use the same pattern for
any randomly created objects.

Performer: Anything that can be seen or heard inherits from the Performer class. Reading image or sound files can be
easily accomplished using the Theme class. New themes and enemy textures can be added to the game without adding any
code, to see how look at the instances of Theme in Menu, and classes that inherit Enemy. Enemy textures just need to
be named after the class that displays them, for an example of how more textures can be used, see the RocketBoss class.

Copy Constructors: There are no static variables in the project other than devMode. Single instances of the state
stack, player and entity lists, random instance, and any other shared references are copied through the
GameLevel(GameLevel) constructor. This is so classes can change their behaviour without breaking other classes, and
the rule of no static variables should continue being followed.
